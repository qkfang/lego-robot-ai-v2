[
  {
    "Module_Name": "App",
    "Module_Description": "The app module is used communicate between hub and app",
    "SubModules": [
      {
        "SubModule_Name": "Bargraph",
        "SubModule_Description": "The bargraph module is used make bar graphs in the SPIKE App",
        "Functions": [
          {
            "Function_Name": "change",
            "Function_Signature": "change(color: int, value: float) -> None",
            "Function_Description": "Parameters",
            "Parameters": [
              {
                "Argument_Name": "color: int",
                "Argument_Description": "A color from the color module"
              },
              {
                "Argument_Name": "value: float",
                "Argument_Description": "The value"
              }
            ],
            "Python_Code": []
          },
          {
            "Function_Name": "clear_all",
            "Function_Signature": "clear_all() -> None",
            "Function_Description": "Parameters",
            "Parameters": [],
            "Python_Code": []
          },
          {
            "Function_Name": "get_value",
            "Function_Signature": "get_value(color: int) -> Awaitable",
            "Function_Description": "Parameters",
            "Parameters": [
              {
                "Argument_Name": "color: int",
                "Argument_Description": "A color from the color module"
              }
            ],
            "Python_Code": []
          },
          {
            "Function_Name": "hide",
            "Function_Signature": "hide() -> None",
            "Function_Description": "Parameters",
            "Parameters": [],
            "Python_Code": []
          },
          {
            "Function_Name": "set_value",
            "Function_Signature": "set_value(color: int, value: float) -> None",
            "Function_Description": "Parameters",
            "Parameters": [
              {
                "Argument_Name": "color: int",
                "Argument_Description": "A color from the color module"
              },
              {
                "Argument_Name": "value: float",
                "Argument_Description": "The value"
              }
            ],
            "Python_Code": []
          },
          {
            "Function_Name": "show",
            "Function_Signature": "show(fullscreen: bool) -> None",
            "Function_Description": "Parameters",
            "Parameters": [
              {
                "Argument_Name": "fullscreen: bool",
                "Argument_Description": "Show in full screen"
              }
            ],
            "Python_Code": []
          }
        ],
        "SubModule_Snippet": [
          {
            "Python_Code": "from app import bargraph",
            "Python_Description": "To use the bargraph module simply import the module like so:"
          }
        ]
      },
      {
        "SubModule_Name": "Display",
        "SubModule_Description": "The display module is used show images in the SPIKE App",
        "Functions": [
          {
            "Function_Name": "hide",
            "Function_Signature": "hide() -> None",
            "Function_Description": "Parameters",
            "Parameters": [],
            "Python_Code": []
          },
          {
            "Function_Name": "image",
            "Function_Signature": "image(image: int) -> None",
            "Function_Description": "Parameters",
            "Parameters": [
              {
                "Argument_Name": "image: int",
                "Argument_Description": "The id of the image to show. The range of available images is 1 to 21. There are consts on      the display module for these"
              }
            ],
            "Python_Code": []
          },
          {
            "Function_Name": "show",
            "Function_Signature": "show(fullscreen: bool) -> None",
            "Function_Description": "Parameters",
            "Parameters": [
              {
                "Argument_Name": "fullscreen: bool",
                "Argument_Description": "Show in full screen"
              }
            ],
            "Python_Code": []
          },
          {
            "Function_Name": "text",
            "Function_Signature": "text(text: str) -> None",
            "Function_Description": "Parameters",
            "Parameters": [
              {
                "Argument_Name": "text: str",
                "Argument_Description": "The text to display"
              }
            ],
            "Python_Code": []
          },
          {
            "Function_Name": "app.display Constants",
            "Function_Signature": "IMAGE_ROBOT_1 = 1\nIMAGE_ROBOT_2 = 2\nIMAGE_ROBOT_3 = 3\nIMAGE_ROBOT_4 = 4\nIMAGE_ROBOT_5 = 5\nIMAGE_HUB_1 = 6\nIMAGE_HUB_2 = 7\nIMAGE_HUB_3 = 8\nIMAGE_HUB_4 = 9\nIMAGE_AMUSEMENT_PARK = 10\nIMAGE_BEACH = 11\nIMAGE_HAUNTED_HOUSE = 12\nIMAGE_CARNIVAL = 13\nIMAGE_BOOKSHELF = 14\nIMAGE_PLAYGROUND = 15\nIMAGE_MOON = 16\nIMAGE_CAVE = 17\nIMAGE_OCEAN = 18\nIMAGE_POLAR_BEAR = 19\nIMAGE_PARK = 20\nIMAGE_RANDOM = 21",
            "Parameters": [],
            "Python_Code": []
          }
        ],
        "SubModule_Snippet": [
          {
            "Python_Code": "from app import display",
            "Python_Description": "To use the display module simply import the module like so:"
          }
        ]
      },
      {
        "SubModule_Name": "Music",
        "SubModule_Description": "The music module is used make music in the SPIKE App",
        "Functions": [
          {
            "Function_Name": "play_drum",
            "Function_Signature": "play_drum(drum: int) -> None",
            "Function_Description": "Parameters",
            "Parameters": [
              {
                "Argument_Name": "drum: int",
                "Argument_Description": "The drum name. See all available values in the app.sound module."
              }
            ],
            "Python_Code": []
          },
          {
            "Function_Name": "play_instrument",
            "Function_Signature": "play_instrument(instrument: int, note: int, duration: int) -> None",
            "Function_Description": "Parameters",
            "Parameters": [
              {
                "Argument_Name": "instrument: int",
                "Argument_Description": "The instrument name. See all available values in the app.music module."
              },
              {
                "Argument_Name": "note: int",
                "Argument_Description": "The midi note to play (0-130)"
              },
              {
                "Argument_Name": "duration: int",
                "Argument_Description": "The duration in milliseconds"
              }
            ],
            "Python_Code": []
          },
          {
            "Function_Name": "app.music Constants",
            "Function_Signature": "DRUM_BASS = 2\nDRUM_BONGO = 13\nDRUM_CABASA = 15\nDRUM_CLAVES = 9\nDRUM_CLOSED_HI_HAT = 6\nDRUM_CONGA = 14\nDRUM_COWBELL = 11\nDRUM_CRASH_CYMBAL = 4\nDRUM_CUICA = 18\nDRUM_GUIRO = 16\nDRUM_HAND_CLAP = 8\nDRUM_OPEN_HI_HAT = 5\nDRUM_SIDE_STICK = 3\nDRUM_SNARE = 1\nDRUM_TAMBOURINE = 7\nDRUM_TRIANGLE = 12\nDRUM_VIBRASLAP = 17\nDRUM_WOOD_BLOCK = 10\nINSTRUMENT_BASS = 6\nINSTRUMENT_BASSOON = 14\nINSTRUMENT_CELLO = 8\nINSTRUMENT_CHOIR = 15\nINSTRUMENT_CLARINET = 10\nINSTRUMENT_ELECTRIC_GUITAR = 5\nINSTRUMENT_ELECTRIC_PIANO = 2\nINSTRUMENT_FLUTE = 12\nINSTRUMENT_GUITAR = 4\nINSTRUMENT_MARIMBA = 19\nINSTRUMENT_MUSIC_BOX = 17\nINSTRUMENT_ORGAN = 3\nINSTRUMENT_PIANO = 1\nINSTRUMENT_PIZZICATO = 7\nINSTRUMENT_SAXOPHONE = 11\nINSTRUMENT_STEEL_DRUM = 18\nINSTRUMENT_SYNTH_LEAD = 20\nINSTRUMENT_SYNTH_PAD = 21\nINSTRUMENT_TROMBONE = 9\nINSTRUMENT_VIBRAPHONE = 16\nINSTRUMENT_WOODEN_FLUTE = 13",
            "Parameters": [],
            "Python_Code": []
          }
        ],
        "SubModule_Snippet": [
          {
            "Python_Code": "from app import music",
            "Python_Description": "To use the music module simply import the module like so:"
          }
        ]
      },
      {
        "SubModule_Name": "Sound",
        "SubModule_Description": "The sound module is used play sounds in the SPIKE App",
        "Functions": [
          {
            "Function_Name": "play",
            "Function_Signature": "play(sound_name: str, volume: int = 100, pitch: int = 0, pan: int = 0) -> Awaitable",
            "Function_Description": "Play a sound in the SPIKE App",
            "Parameters": [
              {
                "Argument_Name": "sound_name: str",
                "Argument_Description": "The sound name as seen in the Word Blocks sound extension"
              },
              {
                "Argument_Name": "volume: int",
                "Argument_Description": "The volume (0-100)"
              },
              {
                "Argument_Name": "pitch: int",
                "Argument_Description": "The pitch of the sound"
              },
              {
                "Argument_Name": "pan: int",
                "Argument_Description": "The pan effect determines which speaker is emitting the sound, with \"-100\" being only the      left speaker, \"0\" being normal, and \"100\" being only the right speaker."
              }
            ],
            "Python_Code": []
          },
          {
            "Function_Name": "set_attributes",
            "Function_Signature": "set_attributes(volume: int, pitch: int, pan: int) -> None",
            "Function_Description": "Parameters",
            "Parameters": [
              {
                "Argument_Name": "volume: int",
                "Argument_Description": "The volume (0-100)"
              },
              {
                "Argument_Name": "pitch: int",
                "Argument_Description": "The pitch of the sound"
              },
              {
                "Argument_Name": "pan: int",
                "Argument_Description": "The pan effect determines which speaker is emitting the sound, with \"-100\" being only the      left speaker, \"0\" being normal, and \"100\" being only the right speaker."
              }
            ],
            "Python_Code": []
          },
          {
            "Function_Name": "stop",
            "Function_Signature": "stop() -> None",
            "Function_Description": "Parameters",
            "Parameters": [],
            "Python_Code": []
          }
        ],
        "SubModule_Snippet": [
          {
            "Python_Code": "from app import sound",
            "Python_Description": "To use the sound module simply import the module like so:"
          }
        ]
      }
    ],
    "Functions": [],
    "Module_Import": []
  },
  {
    "Module_Name": "Color",
    "Module_Description": "The color module contains all the color constants to use with the color_matrix, color_sensor and light modules.",
    "SubModules": [],
    "Functions": [
      {
        "Function_Name": "color Constants",
        "Function_Signature": "BLACK = 0\nMAGENTA = 1\nPURPLE = 2\nBLUE = 3\nAZURE = 4\nTURQUOISE = 5\nGREEN = 6\nYELLOW = 7\nORANGE = 8\nRED = 9\nWHITE = 10\nUNKNOWN = -1",
        "Function_Arguments": [],
        "Function_Snippet": []
      }
    ],
    "Module_Import": [
      {
        "Python_Code": "import color",
        "Python_Description": "To use the Color module add the following import statement to your project:"
      }
    ]
  },
  {
    "Module_Name": "Color Matrix",
    "Module_Description": "To use the Color Matrix module add the following import statement to your project:",
    "SubModules": [],
    "Functions": [
      {
        "Function_Name": "clear",
        "Function_Signature": "clear(port: int) -> None",
        "Function_Description": "Turn off all pixels on a Color Matrix",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          }
        ],
        "Function_Snippet": [
          {
            "Python_Code": "from hub import port\nimport color_matrix\n\ncolor_matrix.clear(port.A)"
          }
        ]
      },
      {
        "Function_Name": "get_pixel",
        "Function_Signature": "get_pixel(port: int, x: int, y: int) -> tuple[int, int]",
        "Function_Description": "Retrieve a specific pixel represented as a tuple containing the color and intensity",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          },
          {
            "Argument_Name": "x: int",
            "Argument_Description": "The X value (0 - 2)"
          },
          {
            "Argument_Name": "y: int",
            "Argument_Description": "The Y value, range (0 - 2)"
          }
        ],
        "Function_Snippet": [
          {
            "Python_Code": "from hub import port\nimport color_matrix\n\n# Print the color and intensity of the 0,0 pixel on the Color Matrix connected to port A \nprint(color_matrix.get_pixel(port.A, 0, 0))"
          }
        ]
      },
      {
        "Function_Name": "set_pixel",
        "Function_Signature": "set_pixel(port: int, x: int, y: int, pixel: tuple[color: int, intensity: int]) -> None",
        "Function_Description": "Change a single pixel on a Color Matrix",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          },
          {
            "Argument_Name": "x: int",
            "Argument_Description": "The X value (0 - 2)"
          },
          {
            "Argument_Name": "y: int",
            "Argument_Description": "The Y value, range (0 - 2)"
          },
          {
            "Argument_Name": "pixel: tuple[color: int, intensity: int]",
            "Argument_Description": "Tuple containing color and intensity, meaning how bright to light up the pixel"
          }
        ],
        "Function_Snippet": [
          {
            "Python_Code": "from hub import port\nimport color\nimport color_matrix\n\n# Change the color of the 0,0 pixel on the Color Matrix connected to port A \ncolor_matrix.set_pixel(port.A, 0, 0, (color.RED, 10))\n\n# Print the color of the 0,0 pixel on the Color Matrix connected to port A \nprint(color_matrix.get_pixel(port.A, 0, 0)[0])"
          }
        ]
      },
      {
        "Function_Name": "show",
        "Function_Signature": "show(port: int, pixels: list[tuple[int, int]]) -> None",
        "Function_Description": "Change all pixels at once on a Color Matrix",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          },
          {
            "Argument_Name": "pixels: list[tuple[int, int]]",
            "Argument_Description": "A list containing color and intensity value tuples for all 9 pixels."
          }
        ],
        "Function_Snippet": [
          {
            "Python_Code": "from hub import port\nimport color\nimport color_matrix\n\n# Update all pixels on Color Matrix using the show function \n\n# Create a list with 18 items (color and intensity pairs) \npixels = [(color.BLUE, 10)] * 9 \n\n# Update all pixels to show same color and intensity \ncolor_matrix.show(port.A, pixels)"
          }
        ]
      }
    ],
    "Module_Import": [
      {
        "Python_Code": "import color_matrix",
        "Python_Description": "To use the Color Matrix module add the following import statement to your project:"
      },
      {
        "Python_Code": "color_matrix.set_pixel(port.A, 1, 1, (color.BLUE, 10))",
        "Python_Description": "All functions in the module should be called inside the color_matrix module as a prefix like so:"
      }
    ]
  },
  {
    "Module_Name": "Color Sensor",
    "Module_Description": "The color_sensor module enables you to write code that reacts to specific colors or the intensity of the reflected light.",
    "SubModules": [],
    "Functions": [
      {
        "Function_Name": "color",
        "Function_Signature": "color(port: int) -> int",
        "Function_Description": "Returns the color value of the detected color. Use the color module to map the color value to a specific color.",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          }
        ],
        "Function_Snippet": [
          {
            "Python_Code": "import color_sensor\nfrom hub import port\nimport color\n\nif color_sensor.color(port.A) is color.RED:\n    print(\"Red detected\")"
          }
        ]
      },
      {
        "Function_Name": "reflection",
        "Function_Signature": "reflection(port: int) -> int",
        "Function_Description": "Retrieves the intensity of the reflected light (0-100%).",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          }
        ],
        "Function_Snippet": []
      },
      {
        "Function_Name": "rgbi",
        "Function_Signature": "rgbi(port: int) -> tuple[int, int, int, int]",
        "Function_Description": "Retrieves the overall color intensity and intensity of red, green and blue.",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          }
        ],
        "Function_Snippet": []
      }
    ],
    "Module_Import": [
      {
        "Python_Code": "import color_sensor",
        "Python_Description": "To use the Color Sensor module add the following import statement to your project:"
      },
      {
        "Python_Code": "color_sensor.reflection(port.A)",
        "Python_Description": "All functions in the module should be called inside the color_sensor module as a prefix like so:"
      }
    ]
  },
  {
    "Module_Name": "Device",
    "Module_Description": "The device module enables you to write code to get information about devices plugged into the hub.",
    "SubModules": [],
    "Functions": [
      {
        "Function_Name": "data",
        "Function_Signature": "data(port: int) -> tuple[int]",
        "Function_Description": "Retrieve the raw LPF-2 data from a device.",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          }
        ],
        "Function_Snippet": []
      },
      {
        "Function_Name": "id",
        "Function_Signature": "id(port: int) -> int",
        "Function_Description": "Retrieve the device id of a device. Each device has an id based on its type.",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          }
        ],
        "Function_Snippet": []
      },
      {
        "Function_Name": "get_duty_cycle",
        "Function_Signature": "get_duty_cycle(port: int) -> int",
        "Function_Description": "Retrieve the duty cycle for a device. Returned values is in range 0 to 10000",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          }
        ],
        "Function_Snippet": []
      },
      {
        "Function_Name": "ready",
        "Function_Signature": "ready(port: int) -> bool",
        "Function_Description": "When a device is attached to the hub it might take a short amount of time before it's ready to accept requests.\nUse ready to test for the readiness of the attached devices.",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          }
        ],
        "Function_Snippet": []
      },
      {
        "Function_Name": "set_duty_cycle",
        "Function_Signature": "set_duty_cycle(port: int, duty_cycle: int) -> None",
        "Function_Description": "Set the duty cycle on a device. Range 0 to 10000",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          },
          {
            "Argument_Name": "duty_cycle: int",
            "Argument_Description": "The PWM value (0-10000)"
          }
        ],
        "Function_Snippet": []
      }
    ],
    "Module_Import": [
      {
        "Python_Code": "import device",
        "Python_Description": "To use the Device module add the following import statement to your project:"
      },
      {
        "Python_Code": "device.device_id(port.A)",
        "Python_Description": "All functions in the module should be called inside the device module as a prefix like so:"
      }
    ]
  },
  {
    "Module_Name": "Distance Sensor",
    "Module_Description": "The distance_sensor module enables you to write code that reacts to specific distances or light up the Distance Sensor in different ways.",
    "SubModules": [],
    "Functions": [
      {
        "Function_Name": "clear",
        "Function_Signature": "clear(port: int) -> None",
        "Function_Description": "Turns off all the lights in the Distance Sensor connected to port.",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          }
        ],
        "Function_Snippet": []
      },
      {
        "Function_Name": "distance",
        "Function_Signature": "distance(port: int) -> int",
        "Function_Description": "Retrieve the distance in millimeters captured by the Distance Sensor connected to port. If the Distance Sensor cannot read a valid distance it will return -1.",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          }
        ],
        "Function_Snippet": []
      },
      {
        "Function_Name": "get_pixel",
        "Function_Signature": "get_pixel(port: int, x: int, y: int) -> int",
        "Function_Description": "Retrieve the intensity of a specific light on the Distance Sensor connected to port.",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          },
          {
            "Argument_Name": "x: int",
            "Argument_Description": "The X value (0 - 3)"
          },
          {
            "Argument_Name": "y: int",
            "Argument_Description": "The Y value, range (0 - 3)"
          }
        ],
        "Function_Snippet": []
      },
      {
        "Function_Name": "set_pixel",
        "Function_Signature": "set_pixel(port: int, x: int, y: int, intensity: int) -> None",
        "Function_Description": "Changes the intensity of a specific light on the Distance Sensor connected to port.",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          },
          {
            "Argument_Name": "x: int",
            "Argument_Description": "The X value (0 - 3)"
          },
          {
            "Argument_Name": "y: int",
            "Argument_Description": "The Y value, range (0 - 3)"
          },
          {
            "Argument_Name": "intensity: int",
            "Argument_Description": "How bright to light up the pixel"
          }
        ],
        "Function_Snippet": []
      },
      {
        "Function_Name": "show",
        "Function_Signature": "show(port: int, pixels: list[int]) -> None",
        "Function_Description": "Change all the lights at the same time.",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          },
          {
            "Argument_Name": "pixels: bytes",
            "Argument_Description": "A list containing intensity values for all 4 pixels."
          }
        ],
        "Function_Snippet": [
          {
            "Python_Code": "from hub import port\nimport distance_sensor\n\n# Update all pixels on Distance Sensor using the show function \n\n# Create a list with 4 identical intensity values \npixels = [100] * 4 \n\n# Update all pixels to show same intensity \ndistance_sensor.show(port.A, pixels)"
          }
        ]
      }
    ],
    "Module_Import": [
      {
        "Python_Code": "import distance_sensor",
        "Python_Description": "To use the Distance Sensor module add the following import statement to your project:"
      },
      {
        "Python_Code": "distance_sensor.distance(port.A)",
        "Python_Description": "All functions in the module should be called inside the distance_sensor module as a prefix like so:"
      }
    ]
  },
  {
    "Module_Name": "Force Sensor",
    "Module_Description": "The force_sensor module contains all functions and constants to use the Force Sensor.",
    "SubModules": [],
    "Functions": [
      {
        "Function_Name": "force",
        "Function_Signature": "force(port: int) -> int",
        "Function_Description": "Retrieves the measured force as decinewton. Values range from 0 to 100",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          }
        ],
        "Function_Snippet": [
          {
            "Python_Code": "from hub import port\nimport force_sensor\n\n\nprint(force_sensor.force(port.A))"
          }
        ]
      },
      {
        "Function_Name": "pressed",
        "Function_Signature": "pressed(port: int) -> bool",
        "Function_Description": "Tests whether the button on the sensor is pressed. Returns true if the force sensor connected to port is pressed.",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          }
        ],
        "Function_Snippet": [
          {
            "Python_Code": "from hub import port\nimport force_sensor\n\n\nprint(force_sensor.pressed(port.A))"
          }
        ]
      },
      {
        "Function_Name": "raw",
        "Function_Signature": "raw(port: int) -> int",
        "Function_Description": "Returns the raw, uncalibrated force value of the force sensor connected on port port",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          }
        ],
        "Function_Snippet": [
          {
            "Python_Code": "from hub import port\nimport force_sensor\n\n\nprint(force_sensor.raw(port.A))"
          }
        ]
      }
    ],
    "Module_Import": [
      {
        "Python_Code": "import force_sensor",
        "Python_Description": "To use the Force Sensor module add the following import statement to your project:"
      },
      {
        "Python_Code": "force_sensor.force(port.A)",
        "Python_Description": "All functions in the module should be called inside the force_sensor module as a prefix like so:"
      }
    ]
  },
  {
    "Module_Name": "Hub",
    "Module_Description": "Sub Modules",
    "SubModules": [
      {
        "SubModule_Name": "Button",
        "SubModule_Description": "To use the Button module add the following import statement to your project:",
        "Functions": [
          {
            "Function_Name": "pressed",
            "Function_Signature": "int pressed(button: int) -> int",
            "Function_Description": "This module allows you to react to buttons being pressed on the hub. You must first import the  button module to use the buttons.",
            "Parameters": [
              {
                "Argument_Name": "button: int",
                "Argument_Description": "A button from the button submodule in the hub module"
              }
            ],
            "Python_Code": [
              {
                "Python_Code": "from hub import button\n\nleft_button_press_duration = 0\n\n# Wait for the left button to be pressed \nwhile not button.pressed(button.LEFT):\n    pass\n\n# As long as the left button is being pressed, update the `left_button_press_duration` variable \nwhile button.pressed(button.LEFT):\n    left_button_press_duration = button.pressed(button.LEFT)\n\nprint(\"Left button was pressed for \" + str(left_button_press_duration) + \" milliseconds\")\n",
                "Python_Description": "This module allows you to react to buttons being pressed on the hub. You must first import the  button module to use the buttons."
              }
            ]
          },
          {
            "Function_Name": "hub.button Constants",
            "Function_Signature": "LEFT = 1\nLeft button next to the power button on the SPIKE Prime  hub\nRIGHT = 2\nRight button next to the power button on the SPIKE  Prime hub",
            "Parameters": [],
            "Python_Code": []
          }
        ],
        "SubModule_Snippet": [
          {
            "Python_Code": "from hub import button",
            "Python_Description": "To use the Button module add the following import statement to your project:"
          },
          {
            "Python_Code": "button.pressed(button.LEFT)",
            "Python_Description": "All functions in the module should be called inside the button module as a prefix like so:"
          }
        ]
      },
      {
        "SubModule_Name": "Light",
        "SubModule_Description": "The light module includes functions to change the color of the light on the SPIKE Prime hub.",
        "Functions": [
          {
            "Function_Name": "color",
            "Function_Signature": "color(light: int, color: int) -> None",
            "Function_Description": "Change the color of a light on the hub.",
            "Parameters": [
              {
                "Argument_Name": "light: int",
                "Argument_Description": "The light on the hub"
              },
              {
                "Argument_Name": "color: int",
                "Argument_Description": "A color from the color module"
              }
            ],
            "Python_Code": [
              {
                "Python_Code": "from hub import light\nimport color\n\n# Change the light to red \nlight.color(light.POWER, color.RED)",
                "Python_Description": "Change the color of a light on the hub."
              }
            ]
          },
          {
            "Function_Name": "hub.light Constants",
            "Function_Signature": "POWER = 0\nThe power button. On SPIKE Prime it's the button between the left  and right buttons.\nCONNECT = 1\nThe light around the Bluetooth connect  button on SPIKE Prime.",
            "Parameters": [],
            "Python_Code": []
          }
        ],
        "SubModule_Snippet": [
          {
            "Python_Code": "from hub import light",
            "Python_Description": "To use the Light module add the following import statement to your project:"
          },
          {
            "Python_Code": "light.color(color.RED)",
            "Python_Description": "All functions in the module should be called inside the light module as a prefix like so:"
          }
        ]
      },
      {
        "SubModule_Name": "Light Matrix",
        "SubModule_Description": "To use the Light Matrix module add the following import statement to your project:",
        "Functions": [
          {
            "Function_Name": "clear",
            "Function_Signature": "clear() -> None",
            "Function_Description": "Switches off all of the pixels on the Light Matrix.",
            "Parameters": [],
            "Python_Code": [
              {
                "Python_Code": "from hub import light_matrix\nimport time\n# Update pixels to show an image on Light Matrix, and then turn them off using the clear function \n\n# Show a small heart \nlight_matrix.show_image(2)\n\n# Wait for two seconds \ntime.sleep_ms(2000)\n\n# Switch off the heart \nlight_matrix.clear()",
                "Python_Description": "Switches off all of the pixels on the Light Matrix."
              }
            ]
          },
          {
            "Function_Name": "get_orientation",
            "Function_Signature": "get_orientation() -> int",
            "Function_Description": "Retrieve the current orientation of the Light Matrix.\n Can be used with the following  constants: orientation.UP, orientation.LEFT,  orientation.RIGHT, orientation.DOWN",
            "Parameters": [],
            "Python_Code": []
          },
          {
            "Function_Name": "get_pixel",
            "Function_Signature": "get_pixel(x: int, y: int) -> int",
            "Function_Description": "Retrieve the intensity of a specific pixel on the Light Matrix.",
            "Parameters": [
              {
                "Argument_Name": "x: int",
                "Argument_Description": "The X value, range (0 - 4)"
              },
              {
                "Argument_Name": "y: int",
                "Argument_Description": "The Y value, range (0 - 4)"
              }
            ],
            "Python_Code": [
              {
                "Python_Code": "from hub import light_matrix\n\n# Show a heart \nlight_matrix.show_image(1)\n\n# Print the value of the center pixel's intensity \nprint(light_matrix.get_pixel(2, 2))\n",
                "Python_Description": "Retrieve the intensity of a specific pixel on the Light Matrix."
              }
            ]
          },
          {
            "Function_Name": "set_orientation",
            "Function_Signature": "set_orientation(top: int) -> int",
            "Function_Description": "Change the orientation of the Light Matrix. All subsequent calls will use the new  orientation.\n Can be used with the following constants: orientation.UP,  orientation.LEFT, orientation.RIGHT, orientation.DOWN",
            "Parameters": [
              {
                "Argument_Name": "top: int",
                "Argument_Description": "The side of the hub to be the top"
              }
            ],
            "Python_Code": []
          },
          {
            "Function_Name": "set_pixel",
            "Function_Signature": "set_pixel(x: int, y: int, intensity: int) -> None",
            "Function_Description": "Sets the brightness of one pixel (one of the 25 LEDs) on the Light Matrix.",
            "Parameters": [
              {
                "Argument_Name": "x: int",
                "Argument_Description": "The X value, range (0 - 4)"
              },
              {
                "Argument_Name": "y: int",
                "Argument_Description": "The Y value, range (0 - 4)"
              },
              {
                "Argument_Name": "intensity: int",
                "Argument_Description": "How bright to light up the pixel"
              }
            ],
            "Python_Code": [
              {
                "Python_Code": "from hub import light_matrix\n# Turn on the pixel in the center of the hub \nlight_matrix.set_pixel(2, 2, 100)",
                "Python_Description": "Sets the brightness of one pixel (one of the 25 LEDs) on the Light Matrix."
              }
            ]
          },
          {
            "Function_Name": "show",
            "Function_Signature": "show(pixels: list[int]) -> None",
            "Function_Description": "Change all the lights at the same time.",
            "Parameters": [
              {
                "Argument_Name": "pixels: Iterable",
                "Argument_Description": "A list containing light intensity values for all 25 pixels."
              }
            ],
            "Python_Code": [
              {
                "Python_Code": "from hub import light_matrix\n# Update all pixels on Light Matrix using the show function \n\n# Create a list with 25 identical intensity values \npixels = [100] * 25 \n\n# Update all pixels to show same intensity \nlight_matrix.show(pixels)",
                "Python_Description": "Change all the lights at the same time."
              }
            ]
          },
          {
            "Function_Name": "show_image",
            "Function_Signature": "show_image(image: int) -> None",
            "Function_Description": "Display one of the built in images on the display.",
            "Parameters": [
              {
                "Argument_Name": "image: int",
                "Argument_Description": "The id of the image to show. The range of available images is 1 to 67. There are consts on      the light_matrix module for these."
              }
            ],
            "Python_Code": [
              {
                "Python_Code": "from hub import light_matrix\n# Update pixels to show an image on Light Matrix using the show_image function \n\n# Show a smiling face \nlight_matrix.show_image(light_matrix.IMAGE_HAPPY)",
                "Python_Description": "Display one of the built in images on the display."
              }
            ]
          },
          {
            "Function_Name": "write",
            "Function_Signature": "write(text: str, intensity: int = 100, time_per_character: int = 500) -> Awaitable",
            "Function_Description": "Displays text on the Light Matrix, one letter at a time, scrolling from right to left except if  there is a single character to show which will not scroll",
            "Parameters": [
              {
                "Argument_Name": "text: str",
                "Argument_Description": "The text to display"
              },
              {
                "Argument_Name": "intensity: int",
                "Argument_Description": "How bright to light up the pixel"
              },
              {
                "Argument_Name": "time_per_character: int",
                "Argument_Description": "How long to show each character on the display"
              }
            ],
            "Python_Code": [
              {
                "Python_Code": "from hub import light_matrix\n# White a message to the hub \nlight_matrix.write(\"Hello, world!\")",
                "Python_Description": "Displays text on the Light Matrix, one letter at a time, scrolling from right to left except if  there is a single character to show which will not scroll"
              }
            ]
          },
          {
            "Function_Name": "hub.light_matrix Constants",
            "Function_Signature": "IMAGE_HEART = 1\nIMAGE_HEART_SMALL = 2\nIMAGE_HAPPY = 3\nIMAGE_SMILE = 4\nIMAGE_SAD = 5\nIMAGE_CONFUSED = 6\nIMAGE_ANGRY = 7\nIMAGE_ASLEEP = 8\nIMAGE_SURPRISED = 9\nIMAGE_SILLY = 10\nIMAGE_FABULOUS = 11\nIMAGE_MEH = 12\nIMAGE_YES = 13\nIMAGE_NO = 14\nIMAGE_CLOCK12 = 15\nIMAGE_CLOCK1 = 16\nIMAGE_CLOCK2 = 17\nIMAGE_CLOCK3 = 18\nIMAGE_CLOCK4 = 19\nIMAGE_CLOCK5 = 20\nIMAGE_CLOCK6 = 21\nIMAGE_CLOCK7 = 22\nIMAGE_CLOCK8 = 23\nIMAGE_CLOCK9 = 24\nIMAGE_CLOCK10 = 25\nIMAGE_CLOCK11 = 26\nIMAGE_ARROW_N = 27\nIMAGE_ARROW_NE = 28\nIMAGE_ARROW_E = 29\nIMAGE_ARROW_SE = 30\nIMAGE_ARROW_S = 31\nIMAGE_ARROW_SW = 32\nIMAGE_ARROW_W = 33\nIMAGE_ARROW_NW = 34\nIMAGE_GO_RIGHT = 35\nIMAGE_GO_LEFT = 36\nIMAGE_GO_UP = 37\nIMAGE_GO_DOWN = 38\nIMAGE_TRIANGLE = 39\nIMAGE_TRIANGLE_LEFT = 40\nIMAGE_CHESSBOARD = 41\nIMAGE_DIAMOND = 42\nIMAGE_DIAMOND_SMALL = 43\nIMAGE_SQUARE = 44\nIMAGE_SQUARE_SMALL = 45\nIMAGE_RABBIT = 46\nIMAGE_COW = 47\nIMAGE_MUSIC_CROTCHET = 48\nIMAGE_MUSIC_QUAVER = 49\nIMAGE_MUSIC_QUAVERS = 50\nIMAGE_PITCHFORK = 51\nIMAGE_XMAS = 52\nIMAGE_PACMAN = 53\nIMAGE_TARGET = 54\nIMAGE_TSHIRT = 55\nIMAGE_ROLLERSKATE = 56\nIMAGE_DUCK = 57\nIMAGE_HOUSE = 58\nIMAGE_TORTOISE = 59\nIMAGE_BUTTERFLY = 60\nIMAGE_STICKFIGURE = 61\nIMAGE_GHOST = 62\nIMAGE_SWORD = 63\nIMAGE_GIRAFFE = 64\nIMAGE_SKULL = 65\nIMAGE_UMBRELLA = 66\nIMAGE_SNAKE = 67",
            "Parameters": [],
            "Python_Code": []
          }
        ],
        "SubModule_Snippet": [
          {
            "Python_Code": "from hub import light_matrix",
            "Python_Description": "To use the Light Matrix module add the following import statement to your project:"
          },
          {
            "Python_Code": "light_matrix.write(\"Hello World\")",
            "Python_Description": "All functions in the module should be called inside the light_matrix module as a prefix like so:"
          }
        ]
      },
      {
        "SubModule_Name": "Motion Sensor",
        "SubModule_Description": "To use the Motion Sensor module add the following import statement to your project:",
        "Functions": [
          {
            "Function_Name": "acceleration",
            "Function_Signature": "acceleration(raw_unfiltered: bool) -> tuple[int, int, int]",
            "Function_Description": "Returns a tuple containing x, y & z acceleration values as integers. The values are mili G,  so 1 / 1000 G",
            "Parameters": [
              {
                "Argument_Name": "raw_unfiltered: bool",
                "Argument_Description": "If we want the data back raw and unfiltered"
              }
            ],
            "Python_Code": []
          },
          {
            "Function_Name": "angular_velocity",
            "Function_Signature": "angular_velocity(raw_unfiltered: bool) -> tuple[int, int, int]",
            "Function_Description": "Returns a tuple containing x, y & z angular velocity values as integers. The values are  decidegrees per second",
            "Parameters": [
              {
                "Argument_Name": "raw_unfiltered: bool",
                "Argument_Description": "If we want the data back raw and unfiltered"
              }
            ],
            "Python_Code": []
          },
          {
            "Function_Name": "gesture",
            "Function_Signature": "gesture() -> int",
            "Function_Description": "Returns the gesture recognized.\nPossible values are:\nmotion_sensor.TAPPED\nmotion_sensor.DOUBLE_TAPPED\nmotion_sensor.SHAKEN\nmotion_sensor.FALLING\nmotion_sensor.UNKNOWN",
            "Parameters": [],
            "Python_Code": []
          },
          {
            "Function_Name": "get_yaw_face",
            "Function_Signature": "get_yaw_face() -> int",
            "Function_Description": "Retrieve the face of the hub that yaw is relative to.\nIf you put the hub on a flat surface  with the face returned pointing up, when you rotate the hub only the yaw will  update\nmotion_sensor.TOP The SPIKE Prime hub face with the USB charging  port.\nmotion_sensor.FRONT The SPIKE Prime hub face with the Light  Matrix.\nmotion_sensor.RIGHT The right side of the SPIKE Prime hub when facing  the front hub face.\nmotion_sensor.BOTTOM The side of the SPIKE Prime hub where  the battery is.\nmotion_sensor.BACK The SPIKE Prime hub face where the speaker  is.\nmotion_sensor.LEFT The left side of the SPIKE Prime hub when facing the  front hub face.",
            "Parameters": [],
            "Python_Code": []
          },
          {
            "Function_Name": "quaternion",
            "Function_Signature": "quaternion() -> tuple[float, float, float, float]",
            "Function_Description": "Returns the hub orientation quaternion as a tuple[w: float, x: float, y: float, z: float].",
            "Parameters": [],
            "Python_Code": []
          },
          {
            "Function_Name": "reset_tap_count",
            "Function_Signature": "reset_tap_count() -> None",
            "Function_Description": "Reset the tap count returned by the tap_count function",
            "Parameters": [],
            "Python_Code": []
          },
          {
            "Function_Name": "reset_yaw",
            "Function_Signature": "reset_yaw(angle: int) -> None",
            "Function_Description": "Change the yaw angle offset.\nThe angle set will be the new yaw value.",
            "Parameters": [],
            "Python_Code": []
          },
          {
            "Function_Name": "set_yaw_face",
            "Function_Signature": "set_yaw_face(up: int) -> bool",
            "Function_Description": "Change what hub face is used as the yaw face.If you put the hub on a flat surface with this face  pointing up, when you rotate the hub only the yaw will update",
            "Parameters": [
              {
                "Argument_Name": "up: int",
                "Argument_Description": "The hub face that should be set as the upwards facing hub face.\nAvailable values are:\nmotion_sensor.TOP The SPIKE Prime hub face with the USB charging      port.\nmotion_sensor.FRONT The SPIKE Prime hub face with the Light      Matrix.\nmotion_sensor.RIGHT The right side of the SPIKE Prime hub when      facing the front hub face.\nmotion_sensor.BOTTOM The side of the SPIKE Prime      hub where the battery is.\nmotion_sensor.BACK The SPIKE Prime hub face where      the speaker is.\nmotion_sensor.LEFT The left side of the SPIKE Prime hub when      facing the front hub face."
              }
            ],
            "Python_Code": []
          },
          {
            "Function_Name": "stable",
            "Function_Signature": "stable() -> bool",
            "Function_Description": "Whether or not the hub is resting flat.",
            "Parameters": [],
            "Python_Code": []
          },
          {
            "Function_Name": "tap_count",
            "Function_Signature": "tap_count() -> int",
            "Function_Description": "Returns the number of taps recognized since the program started or last time  motion_sensor.reset_tap_count() was called.",
            "Parameters": [],
            "Python_Code": []
          },
          {
            "Function_Name": "tilt_angles",
            "Function_Signature": "tilt_angles() -> tuple[int, int, int]",
            "Function_Description": "Returns a tuple containing yaw pitch and roll values as integers. Values are decidegrees",
            "Parameters": [],
            "Python_Code": []
          },
          {
            "Function_Name": "up_face",
            "Function_Signature": "up_face() -> int",
            "Function_Description": "Returns the Hub face that is currently facing up\nmotion_sensor.TOP The SPIKE  Prime hub face with the USB charging port.\nmotion_sensor.FRONT The SPIKE Prime  hub face with the Light Matrix.\nmotion_sensor.RIGHT The right side of the SPIKE  Prime hub when facing the front hub face.\nmotion_sensor.BOTTOM The side of the  SPIKE Prime hub where the battery is.\nmotion_sensor.BACK The SPIKE Prime hub  face where the speaker is.\nmotion_sensor.LEFT The left side of the SPIKE Prime  hub when facing the front hub face.",
            "Parameters": [],
            "Python_Code": []
          },
          {
            "Function_Name": "hub.motion_sensor Constants",
            "Function_Signature": "TAPPED = 0\nDOUBLE_TAPPED = 1\nSHAKEN = 2\nFALLING = 3\nUNKNOWN = -1\nTOP = 0\nThe SPIKE Prime hub face with the Light  Matrix.\nFRONT = 1\nThe SPIKE Prime hub face where the speaker  is.\nRIGHT = 2\nThe right side of the SPIKE Prime hub when facing the front  hub face.\nBOTTOM = 3\nThe side of the SPIKE Prime hub where the battery  is.\nBACK = 4\nThe SPIKE Prime hub face with the USB charging  port.\nLEFT = 5\nThe left side of the SPIKE Prime hub when facing the front  hub face.",
            "Parameters": [],
            "Python_Code": []
          }
        ],
        "SubModule_Snippet": [
          {
            "Python_Code": "from hub import motion_sensor",
            "Python_Description": "To use the Motion Sensor module add the following import statement to your project:"
          },
          {
            "Python_Code": "motion_sensor.up_face()",
            "Python_Description": "All functions in the module should be called inside the motion_sensor module as a prefix like so:"
          }
        ]
      },
      {
        "SubModule_Name": "Sound",
        "SubModule_Description": "To use the Sound module add the following import statement to your project:",
        "Functions": [
          {
            "Function_Name": "beep",
            "Function_Signature": "beep(freq: int = 440, duration: int = 500, volume: int = 100, *, attack: int = 0, decay: int = 0,  sustain: int = 100, release: int = 0, transition: int = 10, waveform: int = WAVEFORM_SINE,  channel: int = DEFAULT) -> Awaitable",
            "Function_Description": "Plays a beep sound from the hub",
            "Parameters": [
              {
                "Argument_Name": "freq: int",
                "Argument_Description": "The frequency to play"
              },
              {
                "Argument_Name": "duration: int",
                "Argument_Description": "The duration in milliseconds"
              },
              {
                "Argument_Name": "volume: int",
                "Argument_Description": "The volume (0-100)"
              },
              {
                "Argument_Name": "attack: int",
                "Argument_Description": "The time taken for initial run-up of level from nil to peak, beginning when the key is      pressed."
              },
              {
                "Argument_Name": "decay: int",
                "Argument_Description": "The time taken for the subsequent run down from the attack level to the designated sustain      level."
              },
              {
                "Argument_Name": "sustain: int",
                "Argument_Description": "The level during the main sequence of the sound's duration, until the key is released."
              },
              {
                "Argument_Name": "release: int",
                "Argument_Description": "The time taken for the level to decay from the sustain level to zero after the key is      released"
              },
              {
                "Argument_Name": "transition: int",
                "Argument_Description": "time in milliseconds to transition into the sound if something is already playing in the      channel"
              },
              {
                "Argument_Name": "waveform: int",
                "Argument_Description": "The synthesized waveform. Use one of the constants in the hub.sound module."
              },
              {
                "Argument_Name": "channel: int",
                "Argument_Description": "The desired channel to play on, options are sound.DEFAULT and      sound.ANY"
              }
            ],
            "Python_Code": []
          },
          {
            "Function_Name": "stop",
            "Function_Signature": "stop() -> None",
            "Function_Description": "Stops all noise from the hub",
            "Parameters": [],
            "Python_Code": []
          },
          {
            "Function_Name": "volume",
            "Function_Signature": "volume(volume: int) -> None",
            "Function_Description": "Parameters",
            "Parameters": [
              {
                "Argument_Name": "volume: int",
                "Argument_Description": "The volume (0-100)"
              }
            ],
            "Python_Code": []
          },
          {
            "Function_Name": "hub.sound Constants",
            "Function_Signature": "ANY = -2\nDEFAULT = -1\nWAVEFORM_SINE = 1\nWAVEFORM_SAWTOOTH = 3\nWAVEFORM_SQUARE = 2\nWAVEFORM_TRIANGLE = 1",
            "Parameters": [],
            "Python_Code": []
          }
        ],
        "SubModule_Snippet": [
          {
            "Python_Code": "from hub import sound",
            "Python_Description": "To use the Sound module add the following import statement to your project:"
          },
          {
            "Python_Code": "sound.stop()",
            "Python_Description": "All functions in the module should be called inside the sound module as a prefix like so:"
          }
        ]
      }
    ],
    "Functions": [
      {
        "Function_Name": "Port",
        "Function_Signature": "This module contains constants that enables easy access to the ports on the SPIKE Prime hub. Use the constants in all functions that takes a port parameter.",
        "Function_Description": "To use the Port module add the following import statement to your project:",
        "Function_Arguments": [
          {
            "Argument_Name": "hub.port Constants",
            "Argument_Description": "A = 0\nThe Port that is labelled \u2018A\u2019 on the Hub.\nB =  1\nThe Port that is labelled \u2018B\u2019 on the Hub.\nC = 2\nThe Port that is  labelled \u2018C\u2019 on the Hub.\nD = 3\nThe Port that is labelled \u2018D\u2019 on the  Hub.\nE = 4\nThe Port that is labelled \u2018E\u2019 on the  Hub.\nF = 5\nThe Port that is labelled \u2018F\u2019 on the Hub."
          }
        ],
        "Function_Snippet": [
          {
            "Python_Code": "from hub import port"
          },
          {
            "Python_Code": "port.A"
          }
        ]
      },
      {
        "Function_Name": "device_uuid",
        "Function_Signature": "device_uuid() -> str",
        "Function_Description": "Retrieve the device id.",
        "Function_Arguments": [],
        "Function_Snippet": []
      },
      {
        "Function_Name": "hardware_id",
        "Function_Signature": "hardware_id() -> str",
        "Function_Description": "Retrieve the hardware id.",
        "Function_Arguments": [],
        "Function_Snippet": []
      },
      {
        "Function_Name": "power_off",
        "Function_Signature": "power_off() -> int",
        "Function_Description": "Turns off the hub.",
        "Function_Arguments": [],
        "Function_Snippet": []
      },
      {
        "Function_Name": "temperature",
        "Function_Signature": "temperature() -> int",
        "Function_Description": "Retrieve the hub temperature. Measured in decidegrees celsius (d\u00b0C) which is 1 / 10 of a degree celsius (\u00b0C)",
        "Function_Arguments": [],
        "Function_Snippet": []
      }
    ],
    "Module_Import": []
  },
  {
    "Module_Name": "Motor",
    "Module_Description": "To use a Motor add the following import statement to your project:",
    "SubModules": [],
    "Functions": [
      {
        "Function_Name": "absolute_position",
        "Function_Signature": "absolute_position(port: int) -> int",
        "Function_Description": "Get the absolute position of a Motor",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          }
        ],
        "Function_Snippet": []
      },
      {
        "Function_Name": "get_duty_cycle",
        "Function_Signature": "get_duty_cycle(port: int) -> int",
        "Function_Description": "Get the pwm of a Motor",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          }
        ],
        "Function_Snippet": []
      },
      {
        "Function_Name": "relative_position",
        "Function_Signature": "relative_position(port: int) -> int",
        "Function_Description": "Get the relative position of a Motor",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          }
        ],
        "Function_Snippet": []
      },
      {
        "Function_Name": "reset_relative_position",
        "Function_Signature": "reset_relative_position(port: int, position: int) -> None",
        "Function_Description": "Change the position used as the offset when using the run_to_relative_position function.",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          },
          {
            "Argument_Name": "position: int",
            "Argument_Description": "The degree of the motor"
          }
        ],
        "Function_Snippet": []
      },
      {
        "Function_Name": "run",
        "Function_Signature": "run(port: int, velocity: int, *, acceleration: int = 1000) -> None",
        "Function_Description": "Start a Motor at a constant speed",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          },
          {
            "Argument_Name": "velocity: int",
            "Argument_Description": "The velocity in degrees/sec\nValue ranges depends on motor type.\nSmall motor (essential): -660 to 660\nMedium motor: -1110 to 1110\nLarge motor: -1050 to 1050"
          },
          {
            "Argument_Name": "acceleration: int",
            "Argument_Description": "The acceleration (deg/sec\u00b2) (1 - 10000)"
          }
        ],
        "Function_Snippet": [
          {
            "Python_Code": "from hub import port\nimport motor, time\n\n# Start motor \nmotor.run(port.A, 1000)\n"
          }
        ]
      },
      {
        "Function_Name": "run_for_degrees",
        "Function_Signature": "run_for_degrees(port: int, degrees: int, velocity: int, *, stop: int = BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable",
        "Function_Description": "Turn a motor for a specific number of degrees\nWhen awaited returns a status of the movement that corresponds to one of the following constants:\nmotor.READY\nmotor.RUNNING\nmotor.STALLED\nmotor.CANCELED\nmotor.ERROR\nmotor.DISCONNECTED",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          },
          {
            "Argument_Name": "degrees: int",
            "Argument_Description": "The number of degrees"
          },
          {
            "Argument_Name": "velocity: int",
            "Argument_Description": "The velocity in degrees/sec\nValue ranges depends on motor type.\nSmall motor (essential): -660 to 660\nMedium motor: -1110 to 1110\nLarge motor: -1050 to 1050"
          },
          {
            "Argument_Name": "stop: int",
            "Argument_Description": "The behavior of the Motor after it has stopped. Use the constants in the motor  module.\nPossible values are\nmotor.COAST to make the motor coast until a  stop\nmotor.BREAK to brake and continue to brake after  stop\nmotor.HOLD to tell the motor to hold it's  position\nmotor.CONTINUE to tell the motor to keep running at whatever velocity  it's running at until it gets another command\nmotor.SMART_COAST to make the  motor brake until stop and then coast and compensate for inaccuracies in the next  command\nmotor.SMART_BRAKE to make the motor brake and continue to brake after  stop and compensate for inaccuracies in the next command"
          },
          {
            "Argument_Name": "acceleration: int",
            "Argument_Description": "The acceleration (deg/sec\u00b2) (1 - 10000)"
          },
          {
            "Argument_Name": "deceleration: int",
            "Argument_Description": "The deceleration (deg/sec\u00b2) (1 - 10000)"
          }
        ],
        "Function_Snippet": []
      },
      {
        "Function_Name": "run_for_time",
        "Function_Signature": "run_for_time(port: int, duration: int, velocity: int, *, stop: int = BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable",
        "Function_Description": "Run a Motor for a limited amount of time\nWhen awaited returns a status of the movement that corresponds to one of the following constants:\nmotor.READY\nmotor.RUNNING\nmotor.STALLED\nmotor.ERROR\nmotor.DISCONNECTED",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          },
          {
            "Argument_Name": "duration: int",
            "Argument_Description": "The duration in milliseconds"
          },
          {
            "Argument_Name": "velocity: int",
            "Argument_Description": "The velocity in degrees/sec\nValue ranges depends on motor type.\nSmall motor (essential): -660 to 660\nMedium motor: -1110 to 1110\nLarge motor: -1050 to 1050"
          },
          {
            "Argument_Name": "stop: int",
            "Argument_Description": "The behavior of the Motor after it has stopped. Use the constants in the motor  module.\nPossible values are\nmotor.COAST to make the motor coast until a  stop\nmotor.BREAK to brake and continue to brake after  stop\nmotor.HOLD to tell the motor to hold it's  position\nmotor.CONTINUE to tell the motor to keep running at whatever velocity  it's running at until it gets another command\nmotor.SMART_COAST to make the  motor brake until stop and then coast and compensate for inaccuracies in the next  command\nmotor.SMART_BRAKE to make the motor brake and continue to brake after  stop and compensate for inaccuracies in the next command"
          },
          {
            "Argument_Name": "acceleration: int",
            "Argument_Description": "The acceleration (deg/sec\u00b2) (1 - 10000)"
          },
          {
            "Argument_Name": "deceleration: int",
            "Argument_Description": "The deceleration (deg/sec\u00b2) (1 - 10000)"
          }
        ],
        "Function_Snippet": [
          {
            "Python_Code": "from hub import port\nimport runloop\nimport motor\n\nasync def main():\n    # Run at 1000 velocity for 1 second \n    await motor.run_for_time(port.A, 1000, 1000)\n\n    # Run at 280 velocity for 1 second \n    await motor_pair.run_for_time(port.A, 1000, 280)\n\n    # Run at 280 velocity for 10 seconds with a slow deceleration \n    await motor_pair.run_for_time(port.A, 10000, 280, deceleration=10)\n\nrunloop.run(main())"
          }
        ]
      },
      {
        "Function_Name": "run_to_absolute_position",
        "Function_Signature": "run_to_absolute_position(port: int, position: int, velocity: int, *, direction: int = motor.SHORTEST_PATH, stop: int = BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable",
        "Function_Description": "Turn a motor to an absolute position.\nWhen awaited returns a status of the movement that corresponds to one of the following constants:\nmotor.READY\nmotor.RUNNING\nmotor.STALLED\nmotor.CANCELED\nmotor.ERROR\nmotor.DISCONNECTED",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          },
          {
            "Argument_Name": "position: int",
            "Argument_Description": "The degree of the motor"
          },
          {
            "Argument_Name": "velocity: int",
            "Argument_Description": "The velocity in degrees/sec\nValue ranges depends on motor type.\nSmall motor (essential): -660 to 660\nMedium motor: -1110 to 1110\nLarge motor: -1050 to 1050"
          },
          {
            "Argument_Name": "direction: int",
            "Argument_Description": "The direction to turn.\nOptions are:\n motor.CLOCKWISE\nmotor.COUNTERCLOCKWISE\nmotor.SHORTEST_PATH\nmotor.LONGEST_PATH"
          },
          {
            "Argument_Name": "stop: int",
            "Argument_Description": "The behavior of the Motor after it has stopped. Use the constants in the motor  module.\nPossible values are\nmotor.COAST to make the motor coast until a  stop\nmotor.BREAK to brake and continue to brake after  stop\nmotor.HOLD to tell the motor to hold it's  position\nmotor.CONTINUE to tell the motor to keep running at whatever velocity  it's running at until it gets another command\nmotor.SMART_COAST to make the  motor brake until stop and then coast and compensate for inaccuracies in the next  command\nmotor.SMART_BRAKE to make the motor brake and continue to brake after  stop and compensate for inaccuracies in the next command"
          },
          {
            "Argument_Name": "acceleration: int",
            "Argument_Description": "The acceleration (deg/sec\u00b2) (1 - 10000)"
          },
          {
            "Argument_Name": "deceleration: int",
            "Argument_Description": "The deceleration (deg/sec\u00b2) (1 - 10000)"
          }
        ],
        "Function_Snippet": []
      },
      {
        "Function_Name": "run_to_relative_position",
        "Function_Signature": "run_to_relative_position(port: int, position: int, velocity: int, *, stop: int = BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable",
        "Function_Description": "Turn a motor to a position relative to the current position.\nWhen awaited returns a status of the movement that corresponds to one of the following constants:\nmotor.READY\nmotor.RUNNING\nmotor.STALLED\nmotor.CANCELED\nmotor.ERROR\nmotor.DISCONNECTED",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          },
          {
            "Argument_Name": "position: int",
            "Argument_Description": "The degree of the motor"
          },
          {
            "Argument_Name": "velocity: int",
            "Argument_Description": "The velocity in degrees/sec\nValue ranges depends on motor type.\nSmall motor (essential): -660 to 660\nMedium motor: -1110 to 1110\nLarge motor: -1050 to 1050"
          },
          {
            "Argument_Name": "stop: int",
            "Argument_Description": "The behavior of the Motor after it has stopped. Use the constants in the motor  module.\nPossible values are\nmotor.COAST to make the motor coast until a  stop\nmotor.BREAK to brake and continue to brake after  stop\nmotor.HOLD to tell the motor to hold it's  position\nmotor.CONTINUE to tell the motor to keep running at whatever velocity  it's running at until it gets another command\nmotor.SMART_COAST to make the  motor brake until stop and then coast and compensate for inaccuracies in the next  command\nmotor.SMART_BRAKE to make the motor brake and continue to brake after  stop and compensate for inaccuracies in the next command"
          },
          {
            "Argument_Name": "acceleration: int",
            "Argument_Description": "The acceleration (deg/sec\u00b2) (1 - 10000)"
          },
          {
            "Argument_Name": "deceleration: int",
            "Argument_Description": "The deceleration (deg/sec\u00b2) (1 - 10000)"
          }
        ],
        "Function_Snippet": []
      },
      {
        "Function_Name": "set_duty_cycle",
        "Function_Signature": "set_duty_cycle(port: int, pwm: int) -> None",
        "Function_Description": "Start a Motor with a specific pwm",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          },
          {
            "Argument_Name": "pwm: int",
            "Argument_Description": "The PWM value (-10000-10000)"
          }
        ],
        "Function_Snippet": []
      },
      {
        "Function_Name": "stop",
        "Function_Signature": "stop(port: int, *, stop: int = BRAKE) -> None",
        "Function_Description": "Stops a motor",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          },
          {
            "Argument_Name": "stop: int",
            "Argument_Description": "The behavior of the Motor after it has stopped. Use the constants in the motor  module.\nPossible values are\nmotor.COAST to make the motor coast until a  stop\nmotor.BREAK to brake and continue to brake after  stop\nmotor.HOLD to tell the motor to hold it's  position\nmotor.CONTINUE to tell the motor to keep running at whatever velocity  it's running at until it gets another command\nmotor.SMART_COAST to make the  motor brake until stop and then coast and compensate for inaccuracies in the next  command\nmotor.SMART_BRAKE to make the motor brake and continue to brake after  stop and compensate for inaccuracies in the next command"
          }
        ],
        "Function_Snippet": [
          {
            "Python_Code": "from hub import port\nimport motor, time\n\n# Start motor \nmotor.run(port.A, 1000)\n\n# Wait for 2 seconds \ntime.sleep_ms(2000)\n\n# Stop motor \nmotor.stop(port.A)"
          }
        ]
      },
      {
        "Function_Name": "velocity",
        "Function_Signature": "velocity(port: int) -> int",
        "Function_Description": "Get the velocity (deg/sec) of a Motor",
        "Function_Arguments": [
          {
            "Argument_Name": "port: int",
            "Argument_Description": "A port from the port submodule in the hub module"
          }
        ],
        "Function_Snippet": []
      },
      {
        "Function_Name": "motor Constants",
        "Function_Signature": "READY = 0\nRUNNING = 1\nSTALLED = 2\nCANCELLED = 3\nERROR = 4\nDISCONNECTED = 5\nCOAST = 0\nBRAKE = 1\nHOLD = 2\nCONTINUE = 3\nSMART_COAST = 4\nSMART_BRAKE = 5\nCLOCKWISE = 0\nCOUNTERCLOCKWISE = 1\nSHORTEST_PATH = 2\nLONGEST_PATH = 3",
        "Function_Arguments": [],
        "Function_Snippet": []
      }
    ],
    "Module_Import": [
      {
        "Python_Code": "import motor",
        "Python_Description": "To use a Motor add the following import statement to your project:"
      },
      {
        "Python_Code": "motor.run(port.A, 1000)",
        "Python_Description": "All functions in the module should be called inside the motor module as a prefix like so:"
      }
    ]
  },
  {
    "Module_Name": "Motor Pair",
    "Module_Description": "The motor_pair module is used to run motors in a synchronized fashion. This mode is optimal for creating drivebases where you'd want a pair of motors to start and stop at the same time.",
    "SubModules": [],
    "Functions": [
      {
        "Function_Name": "move",
        "Function_Signature": "move(pair: int, steering: int, *, velocity: int = 360, acceleration: int = 1000) -> None",
        "Function_Description": "Move a Motor Pair at a constant speed until a new command is given.",
        "Function_Arguments": [
          {
            "Argument_Name": "pair: int",
            "Argument_Description": "The pair slot of the Motor Pair."
          },
          {
            "Argument_Name": "steering: int",
            "Argument_Description": "The steering (-100 to 100)"
          },
          {
            "Argument_Name": "velocity: int",
            "Argument_Description": "The velocity in degrees/sec\nValue ranges depends on motor type.\nSmall motor (essential): -660 to 660\nMedium motor: -1110 to 1110\nLarge motor: -1050 to 1050"
          },
          {
            "Argument_Name": "acceleration: int",
            "Argument_Description": "The acceleration (deg/sec\u00b2) (1 - 10000)"
          }
        ],
        "Function_Snippet": [
          {
            "Python_Code": "from hub import port\nimport runloop\nimport motor_pair\n\nasync def main():\n    # Pair motors on port A and B \n    motor_pair.pair(motor_pair.PAIR_1, port.A, port.B)\n\n    await runloop.sleep_ms(2000)\n\n    # Move straight at default velocity \n    motor_pair.move(motor_pair.PAIR_1, 0)\n\n    await runloop.sleep_ms(2000)\n\n    # Move straight at a specific velocity \n    motor_pair.move(motor_pair.PAIR_1, 0, velocity=280)\n\n    await runloop.sleep_ms(2000)\n\n    # Move straight at a specific velocity and acceleration \n    motor_pair.move(motor_pair.PAIR_1, 0, velocity=280, acceleration=100)\n\nrunloop.run(main())"
          }
        ]
      },
      {
        "Function_Name": "move_for_degrees",
        "Function_Signature": "move_for_degrees(pair: int, degrees: int, steering: int, *, velocity: int = 360, stop: int = motor.BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable",
        "Function_Description": "Move a Motor Pair at a constant speed for a specific number of degrees.\nWhen awaited returns a status of the movement that corresponds to one of the following constants from the motor module:\nmotor.READY\nmotor.RUNNING\nmotor.STALLED\nmotor.CANCELED\nmotor.ERROR\nmotor.DISCONNECTED",
        "Function_Arguments": [
          {
            "Argument_Name": "pair: int",
            "Argument_Description": "The pair slot of the Motor Pair.",
            "Required": true
          },
          {
            "Argument_Name": "degrees: int",
            "Argument_Description": "The number of degrees"
          },
          {
            "Argument_Name": "steering: int",
            "Argument_Description": "The steering (-100 to 100)"
          },
          {
            "Argument_Name": "velocity: int",
            "Argument_Description": "The velocity in degrees/sec\nValue ranges depends on motor type.\nSmall motor (essential): -660 to 660\nMedium motor: -1110 to 1110\nLarge motor: -1050 to 1050"
          },
          {
            "Argument_Name": "stop: int",
            "Argument_Description": "The behavior of the Motor after it has stopped. Use the constants in the motor  module.\nPossible values are\nmotor.COAST to make the motor coast until a  stop\nmotor.BREAK to brake and continue to brake after  stop\nmotor.HOLD to tell the motor to hold it's  position\nmotor.CONTINUE to tell the motor to keep running at whatever velocity  it's running at until it gets another command\nmotor.SMART_COAST to make the  motor brake until stop and then coast and compensate for inaccuracies in the next  command\nmotor.SMART_BRAKE to make the motor brake and continue to brake after  stop and compensate for inaccuracies in the next command"
          },
          {
            "Argument_Name": "acceleration: int",
            "Argument_Description": "The acceleration (deg/sec\u00b2) (1 - 10000)"
          },
          {
            "Argument_Name": "deceleration: int",
            "Argument_Description": "The deceleration (deg/sec\u00b2) (1 - 10000)"
          }
        ],
        "Function_Snippet": [
          {
            "Python_Code": "from hub import port\nimport runloop\nimport motor_pair\n\nasync def main():\n    # Pair motors on port A and B \n    motor_pair.pair(motor_pair.PAIR_1, port.A, port.B)\n\n    # Move straight at default velocity for 90 degrees \n    await motor_pair.move_for_degrees(motor_pair.PAIR_1, 90, 0)\n\n    # Move straight at a specific velocity \n    await motor_pair.move_for_degrees(motor_pair.PAIR_1, 360, 0, velocity=280)\n\n    # Move straight at a specific velocity with a slow deceleration \n    await motor_pair.move_for_degrees(motor_pair.PAIR_1, 360, 0, velocity=280, deceleration=10)\n\nrunloop.run(main())"
          }
        ]
      },
      {
        "Function_Name": "move_for_time",
        "Function_Signature": "move_for_time(pair: int, duration: int, steering: int, *, velocity: int = 360, stop: int = motor.BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable",
        "Function_Description": "Move a Motor Pair at a constant speed for a specific duration.\nWhen awaited returns a status of the movement that corresponds to one of the following constants from the motor module:\nmotor.READY\nmotor.RUNNING\nmotor.STALLED\nmotor.CANCELED\nmotor.ERROR\nmotor.DISCONNECTED",
        "Function_Arguments": [
          {
            "Argument_Name": "pair: int",
            "Argument_Description": "The pair slot of the Motor Pair."
          },
          {
            "Argument_Name": "duration: int",
            "Argument_Description": "The duration in milliseconds"
          },
          {
            "Argument_Name": "steering: int",
            "Argument_Description": "The steering (-100 to 100)"
          },
          {
            "Argument_Name": "velocity: int",
            "Argument_Description": "The velocity in degrees/sec\nValue ranges depends on motor type.\nSmall motor (essential): -660 to 660\nMedium motor: -1110 to 1110\nLarge motor: -1050 to 1050"
          },
          {
            "Argument_Name": "stop: int",
            "Argument_Description": "The behavior of the Motor after it has stopped. Use the constants in the motor  module.\nPossible values are\nmotor.COAST to make the motor coast until a  stop\nmotor.BREAK to brake and continue to brake after  stop\nmotor.HOLD to tell the motor to hold it's  position\nmotor.CONTINUE to tell the motor to keep running at whatever velocity  it's running at until it gets another command\nmotor.SMART_COAST to make the  motor brake until stop and then coast and compensate for inaccuracies in the next  command\nmotor.SMART_BRAKE to make the motor brake and continue to brake after  stop and compensate for inaccuracies in the next command"
          },
          {
            "Argument_Name": "acceleration: int",
            "Argument_Description": "The acceleration (deg/sec\u00b2) (1 - 10000)"
          },
          {
            "Argument_Name": "deceleration: int",
            "Argument_Description": "The deceleration (deg/sec\u00b2) (1 - 10000)"
          }
        ],
        "Function_Snippet": [
          {
            "Python_Code": "from hub import port\nimport runloop\nimport motor_pair\n\nasync def main():\n    # Pair motors on port A and B \n    motor_pair.pair(motor_pair.PAIR_1, port.A, port.B)\n\n    # Move straight at default velocity for 1 second \n    await motor_pair.move_for_time(motor_pair.PAIR_1, 1000, 0)\n\n    # Move straight at a specific velocity for 1 second \n    await motor_pair.move_for_time(motor_pair.PAIR_1, 1000, 0, velocity=280)\n\n    # Move straight at a specific velocity for 10 seconds with a slow deceleration \n    await motor_pair.move_for_time(motor_pair.PAIR_1, 10000, 0, velocity=280, deceleration=10)\n\nrunloop.run(main())"
          }
        ]
      },
      {
        "Function_Name": "move_tank",
        "Function_Signature": "move_tank(pair: int, left_velocity: int, right_velocity: int, *, acceleration: int = 1000) -> None",
        "Function_Description": "Perform a tank move on a Motor Pair at a constant speed until a new command is given.",
        "Function_Arguments": [
          {
            "Argument_Name": "pair: int",
            "Argument_Description": "The pair slot of the Motor Pair."
          },
          {
            "Argument_Name": "left_velocity: int",
            "Argument_Description": "The velocity (deg/sec) of the left motor."
          },
          {
            "Argument_Name": "right_velocity: int",
            "Argument_Description": "The velocity (deg/sec) of the right motor."
          },
          {
            "Argument_Name": "acceleration: int",
            "Argument_Description": "The acceleration (deg/sec\u00b2) (1 - 10000)"
          }
        ],
        "Function_Snippet": [
          {
            "Python_Code": "from hub import port\nimport runloop\nimport motor_pair\n\nasync def main():\n    # Pair motors on port A and B \n    motor_pair.pair(motor_pair.PAIR_1, port.A, port.B)\n\n    # Move straight at default velocity \n    motor_pair.move_tank(motor_pair.PAIR_1, 1000, 1000)\n\n    await runloop.sleep_ms(2000)\n\n    # Turn right \n    motor_pair.move_tank(motor_pair.PAIR_1, 0, 1000)\n\n    await runloop.sleep_ms(2000)\n\n    # Perform tank turn \n    motor_pair.move_tank(motor_pair.PAIR_1, 1000, -1000)\n\nrunloop.run(main())"
          }
        ]
      },
      {
        "Function_Name": "move_tank_for_degrees",
        "Function_Signature": "move_tank_for_degrees(pair: int, degrees: int, left_velocity: int, right_velocity: int, *, stop: int = motor.BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable",
        "Function_Description": "Perform a tank move on a Motor Pair at a constant speed until a new command is given.\nWhen awaited returns a status of the movement that corresponds to one of the following constants from the motor module:\nmotor.READY\nmotor.RUNNING\nmotor.STALLED\nmotor.CANCELED\nmotor.ERROR\nmotor.DISCONNECTED",
        "Function_Arguments": [
          {
            "Argument_Name": "pair: int",
            "Argument_Description": "The pair slot of the Motor Pair. must use motor_pair.PAIR_1 OR motor_pair.PAIR_2 OR motor_pair.PAIR_3.",
            "Required": true
          },
          {
            "Argument_Name": "degrees: int",
            "Argument_Description": "The number of degrees"
          },
          {
            "Argument_Name": "left_velocity: int",
            "Argument_Description": "The velocity (deg/sec) of the left motor."
          },
          {
            "Argument_Name": "right_velocity: int",
            "Argument_Description": "The velocity (deg/sec) of the right motor."
          },
          {
            "Argument_Name": "stop: int",
            "Argument_Description": "The behavior of the Motor after it has stopped. Use the constants in the motor  module.\nPossible values are\nmotor.COAST to make the motor coast until a  stop\nmotor.BREAK to brake and continue to brake after  stop\nmotor.HOLD to tell the motor to hold it's  position\nmotor.CONTINUE to tell the motor to keep running at whatever velocity  it's running at until it gets another command\nmotor.SMART_COAST to make the  motor brake until stop and then coast and compensate for inaccuracies in the next  command\nmotor.SMART_BRAKE to make the motor brake and continue to brake after  stop and compensate for inaccuracies in the next command"
          },
          {
            "Argument_Name": "acceleration: int",
            "Argument_Description": "The acceleration (deg/sec\u00b2) (1 - 10000)"
          },
          {
            "Argument_Name": "deceleration: int",
            "Argument_Description": "The deceleration (deg/sec\u00b2) (1 - 10000)"
          }
        ],
        "Function_Snippet": [
          {
            "Python_Code": "from hub import port\nimport runloop\nimport motor_pair\n\nasync def main():\n    # Pair motors on port A and B \n    motor_pair.pair(motor_pair.PAIR_1, port.A, port.B)\n\n    # Move straight at default velocity for 360 degrees \n    await motor_pair.move_tank_for_degrees(motor_pair.PAIR_1, 360, 1000, 1000)\n\n    # Turn right for 180 degrees \n    await motor_pair.move_tank_for_degrees(motor_pair.PAIR_1, 180, 0, 1000)\n\n    # Perform tank turn for 720 degrees \n    await motor_pair.move_tank_for_degrees(motor_pair.PAIR_1, 720, 1000, -1000)\n\nrunloop.run(main())"
          }
        ]
      },
      {
        "Function_Name": "move_tank_for_time",
        "Function_Signature": "move_tank_for_time(pair: int, left_velocity: int, right_velocity: int, duration: int, *, stop: int = motor.BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable",
        "Function_Description": "Perform a tank move on a Motor Pair at a constant speed for a specific amount of time.\nWhen awaited returns a status of the movement that corresponds to one of the following constants from the motor module:\nmotor.READY\nmotor.RUNNING\nmotor.STALLED\nmotor.CANCELED\nmotor.ERROR\nmotor.DISCONNECTED",
        "Function_Arguments": [
          {
            "Argument_Name": "pair: int",
            "Argument_Description": "The pair slot of the Motor Pair."
          },
          {
            "Argument_Name": "duration: int",
            "Argument_Description": "The duration in milliseconds"
          },
          {
            "Argument_Name": "left_velocity: int",
            "Argument_Description": "The velocity (deg/sec) of the left motor."
          },
          {
            "Argument_Name": "right_velocity: int",
            "Argument_Description": "The velocity (deg/sec) of the right motor."
          },
          {
            "Argument_Name": "stop: int",
            "Argument_Description": "The behavior of the Motor after it has stopped. Use the constants in the motor  module.\nPossible values are\nmotor.COAST to make the motor coast until a  stop\nmotor.BREAK to brake and continue to brake after  stop\nmotor.HOLD to tell the motor to hold it's  position\nmotor.CONTINUE to tell the motor to keep running at whatever velocity  it's running at until it gets another command\nmotor.SMART_COAST to make the  motor brake until stop and then coast and compensate for inaccuracies in the next  command\nmotor.SMART_BRAKE to make the motor brake and continue to brake after  stop and compensate for inaccuracies in the next command"
          },
          {
            "Argument_Name": "acceleration: int",
            "Argument_Description": "The acceleration (deg/sec\u00b2) (1 - 10000)"
          },
          {
            "Argument_Name": "deceleration: int",
            "Argument_Description": "The deceleration (deg/sec\u00b2) (1 - 10000)"
          }
        ],
        "Function_Snippet": [
          {
            "Python_Code": "from hub import port\nimport runloop\nimport motor_pair\n\nasync def main():\n    # Pair motors on port A and B \n    motor_pair.pair(motor_pair.PAIR_1, port.A, port.B)\n\n    # Move straight at default velocity for 1 second \n    await motor_pair.move_tank_for_time(motor_pair.PAIR_1, 1000, 1000, 1000)\n\n    # Turn right for 3 seconds \n    await motor_pair.move_tank_for_time(motor_pair.PAIR_1, 0, 1000, 3000)\n\n    # Perform tank turn for 2 seconds \n    await motor_pair.move_tank_for_time(motor_pair.PAIR_1, 1000, -1000, 2000)\n\nrunloop.run(main())"
          }
        ]
      },
      {
        "Function_Name": "pair",
        "Function_Signature": "pair(pair: int, left_motor: int, right_motor: int) -> None",
        "Function_Description": "pair two motors (left_motor & right_motor) and store the paired motors in pair.\nUse pair in all subsequent motor_pair related function calls.",
        "Function_Arguments": [
          {
            "Argument_Name": "pair: int",
            "Argument_Description": "The pair slot of the Motor Pair."
          },
          {
            "Argument_Name": "left_motor: int",
            "Argument_Description": "The port of the left motor. Use the port submodule in the hub module."
          },
          {
            "Argument_Name": "right_motor: int",
            "Argument_Description": "The port of the right motor. Use the port submodule in the hub module."
          }
        ],
        "Function_Snippet": [
          {
            "Python_Code": "import motor_pair\nfrom hub import port\n\nmotor_pair.pair(motor_pair.PAIR_1, port.A, port.B)"
          }
        ]
      },
      {
        "Function_Name": "stop",
        "Function_Signature": "stop(pair: int, *, stop: int = motor.BRAKE) -> None",
        "Function_Description": "Stops a Motor Pair.",
        "Function_Arguments": [
          {
            "Argument_Name": "pair: int",
            "Argument_Description": "The pair slot of the Motor Pair."
          },
          {
            "Argument_Name": "stop: int",
            "Argument_Description": "The behavior of the Motor after it has stopped. Use the constants in the motor  module.\nPossible values are\nmotor.COAST to make the motor coast until a  stop\nmotor.BREAK to brake and continue to brake after  stop\nmotor.HOLD to tell the motor to hold it's  position\nmotor.CONTINUE to tell the motor to keep running at whatever velocity  it's running at until it gets another command\nmotor.SMART_COAST to make the  motor brake until stop and then coast and compensate for inaccuracies in the next  command\nmotor.SMART_BRAKE to make the motor brake and continue to brake after  stop and compensate for inaccuracies in the next command"
          }
        ],
        "Function_Snippet": [
          {
            "Python_Code": "import motor_pair\n\nmotor_pair.stop(motor_pair.PAIR_1)"
          }
        ]
      },
      {
        "Function_Name": "unpair",
        "Function_Signature": "unpair(pair: int) -> None",
        "Function_Description": "Unpair a Motor Pair.",
        "Function_Arguments": [
          {
            "Argument_Name": "pair: int",
            "Argument_Description": "The pair slot of the Motor Pair."
          }
        ],
        "Function_Snippet": [
          {
            "Python_Code": "import motor_pair\n\nmotor_pair.unpair(motor_pair.PAIR_1)"
          }
        ]
      },
      {
        "Function_Name": "motor_pair Constants",
        "Function_Signature": "PAIR_1 = 0\nFirst Motor Pair\nPAIR_2 = 1\nSecond Motor Pair\nPAIR_3 = 2\nThird Motor Pair",
        "Function_Arguments": [],
        "Function_Snippet": []
      }
    ],
    "Module_Import": [
      {
        "Python_Code": "import motor_pair",
        "Python_Description": "To use the motor_pair module simply import the module like so:"
      },
      {
        "Python_Code": "motor_pair.pair(motor_pair.PAIR_1, port.A, port.B)",
        "Python_Description": "All functions in the module should be called inside the motor_pair module as a prefix like so:"
      }
    ]
  },
  {
    "Module_Name": "Orientation",
    "Module_Description": "The orientation module contains all the orientation constants to use with the light_matrix module.",
    "SubModules": [],
    "Functions": [
      {
        "Function_Name": "orientation Constants",
        "Function_Signature": "UP = 0\nRIGHT = 1\nDOWN = 2\nLEFT = 3",
        "Function_Arguments": [],
        "Function_Snippet": []
      }
    ],
    "Module_Import": [
      {
        "Python_Code": "import orientation",
        "Python_Description": "To use the orientation module add the following import statement to your project:"
      }
    ]
  },
  {
    "Module_Name": "Runloop",
    "Module_Description": "The runloop module contains all functions and constants to use the Runloop.",
    "SubModules": [],
    "Functions": [
      {
        "Function_Name": "run",
        "Function_Signature": "run(*functions: Awaitable) -> None",
        "Function_Description": "Start any number of parallel async functions. This is the function you should use to create programs with a similar structure to Word Blocks.",
        "Function_Arguments": [
          {
            "Argument_Name": "*functions: awaitable",
            "Argument_Description": "The functions to run"
          }
        ],
        "Function_Snippet": []
      },
      {
        "Function_Name": "sleep_ms",
        "Function_Signature": "sleep_ms(duration: int) -> Awaitable",
        "Function_Description": "Pause the execution of the application for any amount of milliseconds.",
        "Function_Arguments": [
          {
            "Argument_Name": "duration: int",
            "Argument_Description": "The duration in milliseconds"
          }
        ],
        "Function_Snippet": [
          {
            "Python_Code": "from hub import light_matrix\nimport runloop\n\nasync def main():\n    light_matrix.write(\"Hi!\")\n    # Wait for ten seconds \n    await runloop.sleep_ms(10000)\n    light_matrix.write(\"Are you still here?\")\n\nrunloop.run(main())\n"
          }
        ]
      },
      {
        "Function_Name": "until",
        "Function_Signature": "until(function: Callable[[], bool], timeout: int = 0) -> Awaitable",
        "Function_Description": "Returns an awaitable that will return when the condition in the function or lambda passed is True or when it times out",
        "Function_Arguments": [
          {
            "Argument_Name": "function: Callable[[], bool]",
            "Argument_Description": "A callable with no parameters that returns either True or  False.\nCallable is anything that can be called, so a def or a  lambda"
          },
          {
            "Argument_Name": "timeout: int",
            "Argument_Description": "A timeout for the function in milliseconds.\nIf the callable does not return True  within the timeout, the until still resolves after the timeout.\n0 means no  timeout, in that case it will not resolve until the callable returns True"
          }
        ],
        "Function_Snippet": [
          {
            "Python_Code": "import color_sensor\nimport color\nfrom hub import port\nimport runloop\n\ndef is_color_red():\n    return color_sensor.color(port.A) is color.RED\n\nasync def main():\n    # Wait until Color Sensor sees red \n    await runloop.until(is_color_red)\n    print(\"Red!\")\n\nrunloop.run(main())\n"
          }
        ]
      }
    ],
    "Module_Import": [
      {
        "Python_Code": "import runloop",
        "Python_Description": "To use the Runloop module add the following import statement to your project:"
      },
      {
        "Python_Code": "runloop.run(some_async_function())",
        "Python_Description": "All functions in the module should be called inside the runloop module as a prefix like so:"
      }
    ]
  }
]