{
  "doc_id": "doc_2",
  "doc_title": "Controlling Motors",
  "doc_text": "### Controlling Motors\n\nYou’re ready to connect and use the motors. Connect a motor to port A and try the program below.\n\n```\nimport motor\nfrom hub import port\n\n# Run a motor on port A for 360 degrees at 720 degrees per second.\nmotor.run_for_degrees(port.A,360,720)\n```\n\nYou should see the motor run 360 degrees (one complete rotation) at 720 degrees (two rotations) per second.\n\nLet’s examine the code line by line.\n\nThe first line imports the `motor` module that controls the motors.\n\nThe second line imports `port` from the `hub` module, which holds the value for each port. You can write `port.A` for port A, `port.B` for port B, and so on to specify the port(s) you want.\n\nThe final line calls the `run_for_degrees()` function with three _arguments_:\n\n1.  The first parameter specifies which motor to run, using the port value.\n2.  The second parameter specifies the number of degrees to run.\n3.  The third parameter specifies at what velocity to run the motor, in degrees per second.\n\n#### Multiple Motors\n\nNow connect a second motor to port B and try the program below.\n\n```\nimport motor\nfrom hub import port\n\n# Run two motors on ports A and B for 360 degrees at 720 degrees per second.\n# The motors run at the same time.\nmotor.run_for_degrees(port.A, 360, 720)\nmotor.run_for_degrees(port.B, 360, 720)\n```\n\nNotice that both motors run 360 degrees (one rotation) at 720 degrees per second, starting and ending at the same time. Since the two motor statements are on separate lines, you might expect them to run one by one. However, they run at the same time because the `run_for_degrees()` is an _awaitable_ function. That means you _can_ wait for it to complete, but you don’t have to. By default, the program immediately continues to the next line of code while the awaitable code runs to completion in the background. This makes it possible to run multiple commands at the same time.\n\n#### Run Loop, Async, and Await\n\nTo effectively use awaitable code with the flexibility to run commands either concurrently or sequentially, you must run your code in an _asynchronous function_ using a _run loop_. The `runloop` module controls the run loop on the Hub, and lets you run asynchronous functions with its `run()` function. An asynchronous function, also known as a _coroutine_, is an awaitable that uses the `async` keyword before the function definition. The convention is to name the coroutine containing your main program `main()`. The code below shows the general structure of a program using a run loop.\n\n```\nimport runloop\n\nasync def main():\n    # Write your program here.\n\nrunloop.run(main())\n```\n\nIn the body of a coroutine, you can use the `await` keyword before calling an awaitable command. This pauses the coroutine until the command completes. Without the keyword, the program immediately continues to the next line of code in the coroutine. You can still use regular (not awaitable) code inside the coroutine. However, doing so will always pause or _block_ the whole program until the command completes.\n\nThe program below defines the `main()` coroutine, which uses the `await` keyword before the two `run_for_degrees()` function calls. It uses the `run()` function from the `runloop` module to run the `main()` coroutine on the final line of code.\n\n```\nimport motor\nimport runloop\nfrom hub import port\n\nasync def main():\n    # Run two motors on ports A and B for 360 degrees at 720 degrees per second.\n    # The motors run after each other.\n    await motor.run_for_degrees(port.A, 360, 720)\n    await motor.run_for_degrees(port.B, 360,720)\n\nrunloop.run(main())\n```\n\nTry the sample code. You should see that both motors run 360 degrees (one rotation) at 720 degrees per second, one at a time.\n\n#### Challenge\n\nCan you change the code to run both motors at the same time again?"
}